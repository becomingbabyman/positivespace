psDirectives = angular.module 'psDirectives', []


####################################################
####################################################
# Form Directives
# Notes:
# - All inputs should be within a form element
# - Form elements should have a unique name attribute
# - This may become an alternative - https://github.com/angular-ui/angular-ui/pull/191


##########################
# <input> or <select> or <textarea>
# Pure HTML manipulation directive to autofill input attributes with logical defaults
# name:         String - REQUIRED      #TODO: see if you can programatically find it by searching up the dom tree for the 'form' elm
# type:         String - default 'text' - only on <input>
# placeholder:  String - default name
# title:        String - default name
# id:           String - default name + random number
fieldDirectiveDefinitionObject =
    restrict: 'E'
    link: (scope, element, attrs) ->
        if element.prop("tagName") == 'INPUT' and !attrs.type?
            attrs.$set 'type', (attrs.type or 'text')
        unless attrs.placeholder? then attrs.$set 'placeholder', attrs.name
        unless attrs.title? then attrs.$set 'title', (attrs.placeholder or attrs.name)
        unless attrs.id? then attrs.$set 'id', "#{attrs.name}#{Math.floor(Math.random()*999999)}"
        # attrs.$set 'name', (attrs.name or attrs.placeholder.replace(///^\s+|\s+$///g, '').split(' ').join('-'))

psDirectives.directive 'input', () ->
    # TODO: get a placeholder plugin to patch old browsers and behave like https://github.com/wduffy/jLabel -- probably just write a directive for the 'placeholder' attribute
    return fieldDirectiveDefinitionObject

psDirectives.directive 'select', () ->
    return fieldDirectiveDefinitionObject

psDirectives.directive 'textarea', () ->
    return fieldDirectiveDefinitionObject  


##########################
# <control-group>
# label:        String - default null
# helpInline:   String - default null
# helpBlock:    String - default null
psDirectives.directive 'controlGroup', () ->

    findInputEl = (element) ->
        e = element.find('input')
        if e.length < 1 then e = element.find('select')
        if e.length < 1 then e = element.find('textarea')
        e

    directiveDefinitionObject =
        restrict: 'E'
        scope:
            label: '@'
            helpInline: '@'
            helpBlock: '@'
        templateUrl: "<%= asset_path('directives/control_group.html') %>"
        transclude: true
        require: '?^form'

        compile: (element, attrs) ->
            inputEl = findInputEl(element)
            type = inputEl.attr('type')
            element.find('.control-group').addClass(type)

            return {
                pre: (scope, element, attrs, formController) ->
                    # Don't need this yet
                post: (scope, element, attrs, formController) ->
                    inputEl = findInputEl(element)

                    scope.input or= {}
                    scope.input.id = inputEl.attr('id')
                    scope.input.name = inputEl.attr('name')
                    scope.input.title = inputEl.attr('title')

                    scope.field = formController[scope.input.name]
                    
                    buildErrorMsg = ->
                        errors = []
                        if scope.field.$error.required  then errors.push "Oops, #{scope.input.title} can't be blank"
                        if scope.field.$error.email     then errors.push "Please enter a valid email address"
                        if scope.field.$error.url       then errors.push "Please enter a valid url, kind of like \"http://example.com\""
                        if scope.field.$error.minlength then errors.push "Keep typing, #{scope.input.title} is too short"
                        if scope.field.$error.maxlength then errors.push "Whoa, #{scope.input.title} is too long"
                        if scope.field.$error.pattern   then errors.push "Whoops, #{scope.input.title} is in the wrong format"
                        scope.field.errorMessage = errors.join(', ')
                    buildErrorMsg() 
                    scope.$watch 'field.$error', (() -> buildErrorMsg()), true

                    # set 'focused' class on control-group
                    scope.hasFocus = false
                    inputEl.bind 'focusin', ->
                        scope.hasFocus = true
                        scope.$apply()
                    inputEl.bind 'focusout', ->
                        scope.hasFocus = false
                        scope.$apply()
            }

    return directiveDefinitionObject

