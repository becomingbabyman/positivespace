psDirectives = angular.module 'psDirectives', []


####################################################
####################################################
# Form Directives
# Notes:
# - All inputs should be within a form element
# - Form elements should have a unique name attribute
# - This may become an alternative - https://github.com/angular-ui/angular-ui/pull/191


##########################
# <input> or <select> or <textarea>
# Pure HTML manipulation directive to autofill input attributes with logical defaults
# name:         String - REQUIRED      #TODO: see if you can programatically find it by searching up the dom tree for the 'form' elm
# type:         String - default 'text' - only on <input>
# placeholder:  String - default name
# title:        String - default name
# id:           String - default name + random number
fieldDirectiveDefinitionObject =
    restrict: 'E'
    link: (scope, element, attrs) ->
        if element.prop("tagName") == 'INPUT' and !attrs.type?
            attrs.$set 'type', (attrs.type or 'text')
        unless attrs.title? then attrs.$set 'title', (attrs.placeholder or attrs.name)
        unless attrs.id? then attrs.$set 'id', "#{attrs.name}#{Math.floor(Math.random()*999999)}"
        # attrs.$set 'name', (attrs.name or attrs.placeholder.replace(///^\s+|\s+$///g, '').split(' ').join('-'))
        
        unless attrs.placeholder? then attrs.$set 'placeholder', attrs.name
        # TODO: jLabel does not work with response inputs that can update other inputs. Decide if we want cross browser compatibility enough to use jLabel. Or roll your own directive.
        # set placeholder - if jLabel is availible use it instead
        # if element.prop("tagName") == 'INPUT'
        #     if _.isFunction element.jLabel
        #         element.jLabel({ speed : 200, opacity : 0.4 })
        #         attrs.$set 'placeholder', ''
        #     else if !attrs.placeholder? 
        #         attrs.$set 'placeholder', attrs.name

psDirectives.directive 'input', () ->
    return fieldDirectiveDefinitionObject

psDirectives.directive 'select', () ->
    return fieldDirectiveDefinitionObject

psDirectives.directive 'textarea', () ->
    return fieldDirectiveDefinitionObject  


##########################
# <control-group>
# label:        String - default null
# helpInline:   String - default null
# helpBlock:    String - default null
psDirectives.directive 'controlGroup', () ->

    findInputEl = (element) ->
        e = element.find('input')
        if e.length < 1 then e = element.find('select')
        if e.length < 1 then e = element.find('textarea')
        e

    directiveDefinitionObject =
        restrict: 'E'
        scope:
            label: '@'
            helpInline: '@'
            helpBlock: '@'
        templateUrl: "<%= asset_path('directives/control_group.html') %>"
        transclude: true
        require: '?^form'

        compile: (element, attrs) ->
            inputEl = findInputEl(element)
            type = inputEl.attr('type')
            element.find('.control-group').addClass(type)

            # link
            return (scope, element, attrs, formController) ->
                inputEl = findInputEl(element)

                scope.input or= {}
                scope.input.id = inputEl.attr('id')
                scope.input.name = inputEl.attr('name')
                scope.input.title = inputEl.attr('title')

                scope.field = formController[scope.input.name]
                
                buildErrorMsg = ->
                    errors = []
                    if scope.field.$error.required  then errors.push "Oops, #{scope.input.title} can't be blank"
                    if scope.field.$error.email     then errors.push "Please enter a valid email address"
                    if scope.field.$error.url       then errors.push "Please enter a valid url, kind of like \"http://example.com\""
                    if scope.field.$error.minlength then errors.push "Keep typing, #{scope.input.title} is too short"
                    if scope.field.$error.maxlength then errors.push "Whoa, #{scope.input.title} is too long"
                    if scope.field.$error.pattern   then errors.push "Whoops, #{scope.input.title} is in the wrong format"
                    scope.field.errorMessage = errors.join(', ')
                buildErrorMsg() 
                scope.$watch 'field.$error', (() -> buildErrorMsg()), true

                # set 'focused' class on control-group
                scope.hasFocus = false
                inputEl.bind 'focusin', ->
                    scope.$apply () ->
                        scope.hasFocus = true
                inputEl.bind 'focusout', ->
                    scope.$apply () ->
                        scope.hasFocus = false

    return directiveDefinitionObject

